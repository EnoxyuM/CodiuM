<html>
<head>
    <link rel="icon" type="image/png" sizes="16x16" href="icons/favicon-16x16.png">
    <link rel="icon" type="image/png" sizes="32x32" href="icons/favicon-32x32.png">
    <link rel="icon" type="image/png" sizes="64x64" href="icons/favicon-64x64.png">
    <meta charset="UTF-8">
    <title>CodiuM</title>
    <style>
        body, html { margin: 0; padding: 0; height: 100vh; overflow: hidden; font-family: sans-serif; background: #1e1e1e; color: #e0e0e0; }
        
        #project-title {
            width: 150px;
            height: 35px;
            margin-right: 5px;
            flex-shrink: 0;
            display: flex;
            align-items: center;
            padding: 0 15px;
            cursor: pointer;
            z-index: 12;
            color: #ccc;
            white-space: nowrap;
            overflow: hidden;
            box-sizing: border-box;
            -webkit-mask-image: linear-gradient(to right, black 85%, transparent 100%);
            mask-image: linear-gradient(to right, black 85%, transparent 100%);
        }
        #project-title:hover {
            background: #4a4a4a;
            border-radius: 6px 6px 0 0;
        }

        #file-tabs {
            display: flex;
            align-items: flex-end;
            background: #3c3c3c;
            padding: 0 10px 0 55px;
            box-sizing: border-box;
            height: 40px;
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            z-index: 11;
            transition: left 0.3s ease, width 0.3s ease;
        }
        
        #tabs-container {
            display: flex;
            flex: 1;
            min-width: 0;
            height: 35px;
            position: absolute;
            top: 5px;
            left: calc(55px + 150px + 5px);
            right: 50px;
            transition: left 0.3s ease;
        }

        #file-tabs.file-panel-open #tabs-container {
            left: 250px;
        }

        #tabs-wrapper {
            display: flex;
            align-items: flex-end;
            min-width: 0; 
            overflow: hidden;
            flex: 0 0 auto; 
        }

        .tab {
            display: flex; 
            align-items: center;
            justify-content: center;
            background: #2d2d2d;
            color: #ccc;
            cursor: pointer;
            border-radius: 6px; 
            margin-right: 2px;
            min-width: 1px;
            overflow: hidden;
            flex-shrink: 0; 
            width: 232px;
            height: 35px;
            box-sizing: border-box;
            position: relative;
            font-size: 14px;
            white-space: nowrap;
        }
        
        .tab span {
            padding: 8px 15px;
            white-space: nowrap;
            overflow: hidden;
            -webkit-mask-image: linear-gradient(to right, black 85%, transparent 100%);
            mask-image: linear-gradient(to right, black 85%, transparent 100%);
        }

        .tab.active {
            background: #1e1e1e; 
            color: #fff;
            border-radius: 6px 6px 0 0; 
            height: 35px;
            border-bottom: none; 
        }

        .tab:not(.active):hover, #add-file-btn:hover { background: #4a4a4a; }
        .tab.dragging { opacity: 0.5; }

        #add-file-btn, #spacer { align-self: center; }
        
        #add-file-btn {
            background: #2d2d2d;
            color: #ccc;
            padding: 8px 12px;
            cursor: pointer;
            border-radius: 6px; 
            font-weight: bold;
            flex-shrink: 0;
            margin-right: 2px;
            height: 30px; 
            box-sizing: border-box;
        }

        #spacer {
            flex: 1 1 auto; 
            min-width: 10px;
        }
        
        #tabs-container.tabs-overflow #spacer { display: none; }
        #tabs-container.tabs-overflow #tabs-wrapper { flex: 1 1 auto; }
        #tabs-container.tabs-overflow .tab { flex: 1 1 232px; width: auto; }

        #copy-btn {
            position: absolute;
            top: 5px;
            right: 80px;
            width: 30px;
            height: 30px;
            background-color: #2d2d2d;
            color: #ccc;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 18px;
            cursor: pointer;
            border-radius: 6px;
            z-index: 12;
            border: 1px solid #3c3c3c;
            user-select: none;
        }
        #copy-btn:hover {
            background-color: #4a4a4a;
            color: #fff;
        }
        
        #paste-project-btn {
            position: absolute;
            top: 5px;
            right: 45px;
            width: 30px;
            height: 30px;
            background-color: #2d2d2d;
            color: #ccc;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 18px;
            cursor: pointer;
            border-radius: 6px;
            z-index: 12;
            border: 1px solid #3c3c3c;
            user-select: none;
        }
        #paste-project-btn:hover {
            background-color: #4a4a4a;
            color: #fff;
        }

        #run-btn {
            position: absolute;
            top: 5px;
            right: 10px;
            width: 30px;
            height: 30px;
            background-color: #2d2d2d;
            color: #ccc;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 18px;
            cursor: pointer;
            border-radius: 6px;
            z-index: 12;
            border: 1px solid #3c3c3c;
            user-select: none;
        }
        #run-btn:hover {
            background-color: #4a4a4a;
            color: #fff;
        }
        
        .live-update-switch {
          position: absolute;
          top: 12px;
          left: 15px;
          width: 28px;
          height: 16px;
          z-index: 12;
        }
        .live-update-switch input { display: none; }

        .slider { position: absolute; cursor: pointer; top: 0; left: 0; right: 0; bottom: 0; background-color: #555; transition: .4s; border-radius: 16px; }
        .slider:before { position: absolute; content: ""; height: 12px; width: 12px; left: 2px; bottom: 2px; background-color: #ccc; transition: .4s; border-radius: 50%; }
        input:checked + .slider { background-color: #292622; }
        input:checked + .slider:before { transform: translateX(12px); }

        #editor { top: 40px; height: calc(100% - 40px); z-index: 10; position: absolute; left: 0; width: 100%; transition: left 0.3s ease, width 0.3s ease; }
        #scene, #console { border: none; position: absolute; left: 0; }
        #scene { height: 100%; top: 0; width: 100%;}
        #editor .CodeMirror { height: 100%; background-color: transparent; }

        #file-panel {
            position: absolute;
            top: 40px;
            left: -250px;
            width: 250px;
            height: calc(100% - 40px);
            background: #252526;
            z-index: 15;
            transition: left 0.3s ease;
            overflow-y: auto;
            border-right: 1px solid #3c3c3c;
            padding: 5px 0;
            box-sizing: border-box;
        }
        #file-panel.open { left: 0; }
        #editor.file-panel-open { left: 250px; width: calc(100% - 250px); }

        .file-entry { padding: 4px 10px; cursor: pointer; white-space: nowrap; overflow: hidden; text-overflow: ellipsis; user-select: none; }
        .file-entry:hover { background-color: #37373d; }
        .file-entry.active { background-color: #094771; }
        .file-entry.folder::before { content: '📁 '; }
        .file-entry.file::before { content: '📄 '; }

        #context-menu {
            position: fixed;
            z-index: 10000;
            background: #2c2c2c;
            border: 1px solid #444;
            border-radius: 4px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.5);
            padding: 5px 0;
            display: none;
        }
        #context-menu div {
            padding: 8px 15px;
            cursor: pointer;
            color: #ccc;
        }
        #context-menu div:hover {
            background: #094771;
            color: #fff;
        }

        .cm-s-monokai.CodeMirror { background: #272822; color: #f8f8f2; }
        .cm-s-monokai div.CodeMirror-selected { background: #49483e; }
        .cm-s-monokai .CodeMirror-line::selection, .cm-s-monokai .CodeMirror-line>span::selection, .cm-s-monokai .CodeMirror-line>span>span::selection { background: rgba(73, 72, 62, .99); }
        .cm-s-monokai .CodeMirror-line::-moz-selection, .cm-s-monokai .CodeMirror-line>span::-moz-selection, .cm-s-monokai .CodeMirror-line>span>span::-moz-selection { background: rgba(73, 72, 62, .99); }
        .cm-s-monokai .CodeMirror-gutters { background: #272822; border-right: 0; }
        .cm-s-monokai .CodeMirror-guttermarker { color: white; }
        .cm-s-monokai .CodeMirror-guttermarker-subtle { color: #d0d0d0; }
        .cm-s-monokai .CodeMirror-linenumber { color: #d0d0d0; }
        .cm-s-monokai .CodeMirror-cursor { border-left: 1px solid #f8f8f0; }
        .cm-s-monokai span.cm-comment { color: #75715e; }
        .cm-s-monokai span.cm-atom { color: #ae81ff; }
        .cm-s-monokai span.cm-number { color: #ae81ff; }
        .cm-s-monokai span.cm-comment.cm-attribute { color: #97b757; }
        .cm-s-monokai span.cm-comment.cm-def { color: #bc9262; }
        .cm-s-monokai span.cm-comment.cm-tag { color: #bc6283; }
        .cm-s-monokai span.cm-comment.cm-type { color: #5998a6; }
        .cm-s-monokai span.cm-attribute, .cm-s-monokai span.cm-property { color: #a6e22e; }
        .cm-s-monokai span.cm-keyword { color: #f92672; }
        .cm-s-monokai span.cm-string { color: #e6db74; }
        .cm-s-monokai span.cm-variable { color: #f8f8f2; }
        .cm-s-monokai span.cm-variable-2 { color: #9effff; }
        .cm-s-monokai span.cm-variable-3, .cm-s-monokai span.cm-type { color: #66d9ef; }
        .cm-s-monokai span.cm-def { color: #fd971f; }
        .cm-s-monokai span.cm-bracket { color: #f8f8f2; }
        .cm-s-monokai span.cm-tag { color: #f92672; }
        .cm-s-monokai span.cm-header { color: #ae81ff; }
        .cm-s-monokai span.cm-link { color: #ae81ff; }
        .cm-s-monokai span.cm-error { background: #f92672; color: #f8f8f0; }
        .cm-s-monokai .CodeMirror-activeline-background { background: #373831; }
        .cm-s-monokai .CodeMirror-matchingbracket { text-decoration: underline; color: white !important; }
        #console { top: auto; height: 30%; bottom: 0; background-color: rgba(0, 0, 0, 0.8); color: #fff; overflow-y: auto; display: none; z-index: 20; padding: 10px; box-sizing: border-box; font-family: monospace; width: 100%; }
        .error { color: #ff6b6b; }
        .log { color: #4ecdc4; }
        #scene { pointer-events: auto; }
        #editor { pointer-events: none; }
        .CodeMirror-matchingbracket { background-color: #ff0000 !important; color: #000000 !important; }
        .cm-matchhighlight { background-color: #774a77; }
        .CodeMirror-selection-highlight-scrollbar { background-color: #4a4a4a; }
        #menu {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(30, 30, 30, 0.95);
            border: 1px solid #444;
            padding: 20px;
            max-height: 80vh;
            display: none;
            z-index: 1000;
            flex-direction: row;
            gap: 20px;
            box-sizing: border-box;
            border-radius: 12px;
            box-shadow: 0 5px 25px rgba(0, 0, 0, 0.5);
        }
        #menu button { display: flex; justify-content: space-between; align-items: center; width: 100%; padding: 10px; margin: 5px 0; background: #333; color: #fff; border: none; cursor: pointer; text-align: left; box-sizing: border-box; border-radius: 8px; }
        #menu button:hover { background: #444; }
        #menu button.selected { background: #555; }
        #menu button .name { color: #ff9800; font-weight: bold; display: block; }
        #saveBtn { background: #4CAF50 !important; }
        #saveBtn:hover { background: #45a049 !important; }
        #fileInfo { margin-bottom: 10px; }
        #colorPicker { position: fixed; top: 50%; right: 20px; transform: translateY(-50%); background: rgba(30, 30, 30, 0.9); border: 1px solid #444; padding: 20px; display: none; flex-direction: column; align-items: center; z-index: 1000; max-height: 80vh; overflow-y: auto; border-radius: 12px; box-shadow: 0 5px 25px rgba(0, 0, 0, 0.3); }
        .color-item { display: flex; align-items: center; margin-bottom: 10px; width: 100%; }
        .color-item label { flex: 1; margin-right: 10px; }
        .color-item input[type="color"] { width: 50px; }
        #colorThemeBtn { padding: 5px 10px; background: #4CAF50; color: white; border: none; cursor: pointer; z-index: 1001; border-radius: 8px; }
        #colorThemeBtn:hover { background: #45a049; }
        #importBtn, #exportBtn { display: inline-block; margin-top: 10px; padding: 5px 10px; background: #4CAF50; color: white; border: none; cursor: pointer; border-radius: 8px; }
        #importBtn:hover, #exportBtn:hover { background: #45a049; }
        
        #menu-controls { flex: 0 0 180px; display: flex; flex-direction: column; }
        #menu-main-actions { flex: 1; display: flex; flex-direction: column; justify-content: center; }
        #project-list { flex: 1 1 auto; overflow-y: auto; max-height: calc(80vh - 40px); scrollbar-width: thin; scrollbar-color: #555 transparent; }
        
        #project-list::-webkit-scrollbar { width: 14px; }
        #project-list::-webkit-scrollbar-track { background: transparent; }
        #project-list::-webkit-scrollbar-thumb { background-color: #555; border-radius: 7px; border: 3px solid rgba(30, 30, 30, 0.95); }
        #project-list::-webkit-scrollbar-thumb:hover { background-color: #777; }
        #project-list::-webkit-scrollbar-button:single-button { background-color: transparent; display: block; border-style: solid; height: 10px; width: 14px; }
        #project-list::-webkit-scrollbar-button:single-button:hover { background-color: rgba(255, 255, 255, 0.1); }
        #project-list::-webkit-scrollbar-button:single-button:vertical:decrement { border-width: 0 5px 5px 5px; border-color: transparent transparent #999 transparent; }
        #project-list::-webkit-scrollbar-button:single-button:vertical:increment { border-width: 5px 5px 0 5px; border-color: #999 transparent transparent transparent; }

        #project-list button { min-width: 180px; }
        #menu-controls #fileInfo { padding-top: 10px; border-top: 1px solid #444; margin-bottom: 0; }
        .export-arrow { display: inline-flex; visibility: hidden; align-items: center; justify-content: center; width: 20px; height: 20px; background-color: #2a2a2a; border: 1px solid #444; border-radius: 6px; color: #ccc; font-size: 12px; line-height: 1; cursor: pointer; margin-left: 10px; transition: background-color 0.2s, color 0.2s, filter 0.3s; }
        #project-list.show-export-arrows .export-arrow { visibility: visible; }
        .export-arrow:hover { background-color: #555; color: #fff; }
        .export-arrow.exported { filter: brightness(0.5); }
        #notification { position: fixed; bottom: 20px; left: 50%; transform: translateX(-50%); background-color: #4CAF50; color: white; padding: 15px; border-radius: 6px; z-index: 2000; opacity: 0; transition: opacity 0.5s ease-in-out; pointer-events: none; box-shadow: 0 3px 10px rgba(0,0,0,0.5); }
    </style>
    <script>
      if (location.hash === '#t' || location.hash.startsWith('#t=')) {
        document.write(`<style>
            body, html { background: #fff !important; }
            #file-tabs, #file-panel, #editor, #menu, #colorPicker, .live-update-switch, #console, #context-menu, #notification, #run-btn, #copy-btn, #paste-project-btn { display: none !important; }
            #scene {
                position: fixed; top: 0; left: 0;
                width: 100vw; height: 100vh;
                border: none; visibility: visible;
                pointer-events: auto;
            }
        </style>`);
      }
    </script>
    <script src="https://unpkg.com/pako@2.0.4/dist/pako.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.62.0/codemirror.min.js"></script>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.62.0/codemirror.min.css">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.62.0/theme/monokai.min.css">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.62.0/mode/htmlmixed/htmlmixed.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.62.0/mode/javascript/javascript.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.62.0/mode/css/css.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.62.0/mode/xml/xml.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.62.0/addon/edit/matchbrackets.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.62.0/addon/search/match-highlighter.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.62.0/addon/scroll/annotatescrollbar.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.62.0/addon/search/matchesonscrollbar.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.62.0/addon/mode/simple.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js"></script>
</head>
<body>
    <label class="live-update-switch">
        <input type="checkbox" id="liveUpdateToggle" checked>
        <span class="slider"></span>
    </label>
    
    <div id="file-tabs">
        <div id="project-title">📁 Project</div>
        <div id="tabs-container">
             <div id="tabs-wrapper"></div>
             <div id="add-file-btn" title="New File (in root)">+</div>
             <div id="spacer"></div>
        </div>
        <div id="copy-btn" title="Copy all files to clipboard">📋</div>
        <div id="paste-project-btn" title="Create project from clipboard">📜</div>
        <div id="run-btn" title="Save and Run in New Tab">▶</div>
    </div>

    <div id="file-panel"></div>
    <div id="context-menu"></div>
    
    <div id="editor"></div>
    <iframe id="scene"></iframe>
    <div id="console"></div>
    <div id="menu"></div>
    <div id="colorPicker">
        <div class="color-item"><label for="Comment">Comment</label><input type="color" id="Comment"></div><div class="color-item"><label for="Keyword">Keyword</label><input type="color" id="Keyword"></div><div class="color-item"><label for="String">String</label><input type="color" id="String"></div><div class="color-item"><label for="Number">Number</label><input type="color" id="Number"></div><div class="color-item"><label for="Special">Special</label><input type="color" id="Special"></div><div class="color-item"><label for="Variable">Variable</label><input type="color" id="Variable"></div><div class="color-item"><label for="Property">Property</label><input type="color" id="Property"></div><div class="color-item"><label for="Definition">Definition</label><input type="color" id="Definition"></div><div class="color-item"><label for="Function">Function</label><input type="color" id="Function"></div><div class="color-item"><label for="Operator">Operator</label><input type="color" id="Operator"></div><div class="color-item"><label for="HTMLBracket">HTML Bracket</label><input type="color" id="HTMLBracket"></div><div class="color-item"><label for="HighlightedBracket">Highlighted Bracket</label><input type="color" id="HighlightedBracket"></div><div class="color-item"><label for="Class">Class</label><input type="color" id="Class"></div><div class="color-item"><label for="Regex">Regex</label><input type="color" id="Regex"></div><div class="color-item"><label for="HTMLTag">HTML Tag</label><input type="color" id="HTMLTag"></div><div class="color-item"><label for="HTMLAttribute">HTML Attribute</label><input type="color" id="HTMLAttribute"></div><div class="color-item"><label for="OtherText">Other Text</label><input type="color" id="OtherText"></div><button id="importBtn">Import</button><button id="exportBtn">Export</button>
    </div>
<script>
const isPreviewMode = location.hash === '#t' || location.hash.startsWith('#t=');

const editorElement = document.getElementById('editor');
let editor;

if (!isPreviewMode) {
    editor = CodeMirror(editorElement, {
        lineNumbers: true,
        mode: "htmlmixed",
        theme: "monokai",
        lineWrapping: true,
        viewportMargin: Infinity,
        matchBrackets: true,
        autoCloseBrackets: true,
        indentUnit: 4,
        tabSize: 4,
        indentWithTabs: false,
        extraKeys: {
            "Ctrl-Space": "autocomplete",
            "Ctrl-S": function(cm) {
                saveCurrentCode(true);
                return false;
            }
        },
        highlightSelectionMatches: {showToken: /\w/, annotateScrollbar: true}
    });
} else {
    editorElement.remove();
}

const scene = document.getElementById('scene');
const consoleElem = document.getElementById('console');
const menu = document.getElementById('menu');
const projectTitle = document.getElementById('project-title');
const filePanel = document.getElementById('file-panel');
const tabsContainer = document.getElementById('tabs-container');
const tabsWrapper = document.getElementById('tabs-wrapper');
const colorPicker = document.getElementById('colorPicker');
const importBtn = document.getElementById('importBtn');
const exportBtn = document.getElementById('exportBtn');
const liveUpdateToggle = document.getElementById('liveUpdateToggle');
const contextMenu = document.getElementById('context-menu');
const runBtn = document.getElementById('run-btn');
const copyBtn = document.getElementById('copy-btn');
const pasteProjectBtn = document.getElementById('paste-project-btn');

let files = {};
let openTabs = [];
let activeFilePath = null;
let currentProjectId = null;
let currentSortMode = localStorage.getItem('projectSortMode') || 'created';
const blobUrls = [];

const initialFiles = { 'index.html': { code: ``, doc: CodeMirror.Doc(``, 'htmlmixed') } };

function checkOverflow() {
    if (isPreviewMode) return;
    const addBtn = document.getElementById('add-file-btn');
    if (!addBtn || !tabsContainer) return;

    const TAB_FULL_WIDTH = 232;
    const TAB_MARGIN = 2;

    const requiredSpace = (openTabs.length * (TAB_FULL_WIDTH + TAB_MARGIN)) + addBtn.offsetWidth;
    const availableSpace = tabsContainer.clientWidth - 20;

    if (requiredSpace > availableSpace) {
        tabsContainer.classList.add('tabs-overflow');
    } else {
        tabsContainer.classList.remove('tabs-overflow');
    }
}

function renderTabs() {
    tabsWrapper.innerHTML = '';
    
    openTabs.forEach(filepath => {
        if (!files[filepath]) return;
        
        const tab = document.createElement('div');
        tab.className = 'tab';
        tab.dataset.filepath = filepath;
        
        const shortName = filepath.split('/').pop();
        tab.title = filepath;

        const tabTextSpan = document.createElement('span');
        tabTextSpan.textContent = shortName;
        tab.appendChild(tabTextSpan);

        if (filepath !== 'index.html') tab.draggable = true;
        if (filepath === activeFilePath) tab.classList.add('active');

        tab.onclick = () => switchTab(filepath);

        tab.addEventListener('mousedown', (e) => {
            if (e.button === 1) {
                e.preventDefault();
                closeTab(filepath);
            }
        });
        
        tab.addEventListener('contextmenu', e => {
            e.preventDefault();
            if (filepath === 'index.html') {
                showNotification("Cannot rename index.html.");
                return;
            }
            renameItem(filepath, false);
        });

        tab.addEventListener('dragstart', () => setTimeout(() => tab.classList.add('dragging'), 0));
        tab.addEventListener('dragend', () => tab.classList.remove('dragging'));

        tabsWrapper.appendChild(tab);
    });
    
    setTimeout(checkOverflow, 0);
}

function showNotification(message) {
    let el = document.getElementById('notification');
    if (!el) {
        el = document.createElement('div');
        el.id = 'notification';
        document.body.appendChild(el);
    }
    el.textContent = message;
    el.style.opacity = '1';
    setTimeout(() => { el.style.opacity = '0'; }, 3000);
}

const URL_ALPHABET = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789!#$%&()*+-;=@[]^_{}~,.:?/";
const BASE = BigInt(URL_ALPHABET.length);
const ALPHABET_MAP = new Map(URL_ALPHABET.split('').map((c, i) => [c, BigInt(i)]));

function encodeBaseCustom(bytes) {
    if (bytes.length === 0) return '';
    let leadingZeros = 0;
    for (let i = 0; i < bytes.length && bytes[i] === 0; i++)  leadingZeros++;
    let num = 0n;
    for (let i = leadingZeros; i < bytes.length; i++) num = (num << 8n) + BigInt(bytes[i]);
    let encoded = '';
    while (num > 0) { const remainder = num % BASE; num /= BASE; encoded = URL_ALPHABET[Number(remainder)] + encoded; }
    return URL_ALPHABET[0].repeat(leadingZeros) + encoded;
}

function decodeBaseCustom(str) {
    if (str.length === 0) return new Uint8Array();
    let leadingZeros = 0;
    for (let i = 0; i < str.length && str[i] === URL_ALPHABET[0]; i++) leadingZeros++;
    let num = 0n;
    for (let i = leadingZeros; i < str.length; i++) {
        const charValue = ALPHABET_MAP.get(str[i]);
        if (charValue === undefined) throw new Error(`Invalid character in input: ${str[i]}`);
        num = num * BASE + charValue;
    }
    const bytes = [];
    while (num > 0) { bytes.push(Number(num & 255n)); num >>= 8n; }
    return new Uint8Array([...Array(leadingZeros).fill(0), ...bytes.reverse()]);
}

function encodeVarint(value) {
    const bytes = [];
    while (value >= 0x80) { bytes.push((value & 0x7F) | 0x80); value >>>= 7; }
    bytes.push(value);
    return new Uint8Array(bytes);
}

function decodeVarint(bytes, offset) {
    let value = 0, shift = 0, currentOffset = offset;
    while (true) {
        if (currentOffset >= bytes.length) throw new Error("Malformed Varint: Unexpected end of buffer.");
        const byte = bytes[currentOffset++];
        value |= (byte & 0x7F) << shift;
        if ((byte & 0x80) === 0) return { value, newOffset: currentOffset };
        shift += 7;
    }
}

function serializeProjectOptimized(projectFileOrder, projectFiles) {
    const textEncoder = new TextEncoder();
    const parts = [];

    projectFileOrder.forEach(name => {
        if (!projectFiles[name] || name.split('/').pop() === '.p') return;
        const code = projectFiles[name].code;
        const nameBytes = textEncoder.encode(name);
        const codeBytes = textEncoder.encode(code);

        parts.push(encodeVarint(nameBytes.length));
        parts.push(nameBytes);
        parts.push(encodeVarint(codeBytes.length));
        parts.push(codeBytes);
    });

    const totalLength = parts.reduce((acc, part) => acc + part.length, 0);
    const result = new Uint8Array(totalLength);
    let offset = 0;
    for (const part of parts) { result.set(part, offset); offset += part.length; }
    return result;
}

function deserializeProjectOptimized(bytes) {
    const textDecoder = new TextDecoder();
    const filesToLoad = {};
    const fileOrderToLoad = [];
    let offset = 0;

    while (offset < bytes.length) {
        const nameLenResult = decodeVarint(bytes, offset);
        const nameLen = nameLenResult.value;
        offset = nameLenResult.newOffset;
        
        const name = textDecoder.decode(bytes.subarray(offset, offset + nameLen));
        offset += nameLen;

        const codeLenResult = decodeVarint(bytes, offset);
        const codeLen = codeLenResult.value;
        offset = codeLenResult.newOffset;

        const code = textDecoder.decode(bytes.subarray(offset, offset + codeLen));
        offset += codeLen;

        filesToLoad[name] = code;
        fileOrderToLoad.push(name);
    }
    
    return { filesToLoad, fileOrderToLoad };
}

async function generateShareableUrl(prefix = '#p=') {
    try {
        if (activeFilePath) files[activeFilePath].code = editor.getValue();
        
        const fileList = Object.keys(files);
        const binaryData = serializeProjectOptimized(fileList, files);
        
        const compressed = pako.gzip(binaryData, { level: 9 });
        
        const encodedData = encodeBaseCustom(compressed);
        
        const url = `${location.origin}${location.pathname}${prefix}${encodedData}`;
        await navigator.clipboard.writeText(url);
        showNotification(prefix === '#p=' ? 'URL link copied' : 'Preview link copied');
    } catch (e) {
        console.error("Share error:", e);
        showNotification('Error creating link');
    }
}

async function loadFromUrlHash() {
    if (!location.hash.startsWith('#p=')) return false;
    try {
        const encodedData = location.hash.substring(3);
        const compressedBytes = decodeBaseCustom(encodedData);
        const decompressed = pako.ungzip(compressedBytes);
        const binaryData = new Uint8Array(decompressed);
        const { filesToLoad } = deserializeProjectOptimized(binaryData);

        if (Object.keys(filesToLoad).length > 0) {
            initializeEditorWithFiles(filesToLoad, ['index.html']);
            currentProjectId = null;
            updateProjectTitle();
            history.replaceState(null, '', location.pathname + location.search);
            showNotification('URL Project loaded');
            return true;
        }
    } catch(e) { 
        console.error("URL load error:", e); 
        showNotification('Invalid or corrupted link');
    }
    return false;
}

function getModeForFilename(filename) {
    if (filename.endsWith('.js')) return 'javascript';
    if (filename.endsWith('.html')) return 'htmlmixed';
    if (filename.endsWith('.css')) return 'css';
    return 'text/plain';
}

function initializeEditorWithFiles(fileSet, loadedOpenTabs) {
    files = {};
    for (const filepath in fileSet) {
        const code = fileSet[filepath];
        const mode = getModeForFilename(filepath);
        files[filepath] = { code: code, doc: CodeMirror.Doc(code, mode) };
    }
    
    openTabs = loadedOpenTabs.filter(f => files[f]);
    if (openTabs.length === 0) {
        openTabs = ['index.html'].filter(f => files[f]);
    }

    activeFilePath = 'index.html';
    if (!files[activeFilePath] || !openTabs.includes(activeFilePath)) {
      activeFilePath = openTabs.length > 0 ? openTabs[0] : null;
    }

    if (activeFilePath && files[activeFilePath]) {
        editor.swapDoc(files[activeFilePath].doc);
        editor.setOption('mode', getModeForFilename(activeFilePath));
    } else {
        editor.setValue('');
    }
    
    renderAll();
    updateScene();
}

if (!isPreviewMode) {
    window.addEventListener('resize', checkOverflow);
}


function getDragAfterElement(container, x) {
    const draggableElements = [...container.querySelectorAll('.tab[draggable="true"]:not(.dragging)')];
    return draggableElements.reduce((closest, child) => {
        const box = child.getBoundingClientRect();
        const offset = x - box.left - box.width / 2;
        if (offset < 0 && offset > closest.offset) {
            return { offset: offset, element: child };
        } else {
            return closest;
        }
    }, { offset: Number.NEGATIVE_INFINITY }).element;
}
if (!isPreviewMode) {
    tabsWrapper.addEventListener('dragover', e => {
        e.preventDefault();
        const afterElement = getDragAfterElement(tabsWrapper, e.clientX);
        const dragging = document.querySelector('.dragging');
        if (dragging) {
            if (afterElement == null) {
                tabsWrapper.appendChild(dragging);
            } else {
                tabsWrapper.insertBefore(dragging, afterElement);
            }
        }
    });

    tabsWrapper.addEventListener('drop', e => {
        e.preventDefault();
        openTabs = Array.from(tabsWrapper.querySelectorAll('.tab')).map(tab => tab.dataset.filepath);
    });
}


function switchTab(filepath) {
    if (filepath === activeFilePath || !files[filepath]) return;
    if (activeFilePath && files[activeFilePath]) files[activeFilePath].code = editor.getValue();

    activeFilePath = filepath;
    editor.swapDoc(files[filepath].doc);
    editor.setOption('mode', getModeForFilename(filepath));
    renderAll(); 
    editor.focus();
}

function openFile(filepath) {
    if (!files[filepath]) return;
    if (!openTabs.includes(filepath)) {
        openTabs.push(filepath);
    }
    switchTab(filepath);
}

function closeTab(filepath) {
    if (filepath === 'index.html') {
        alert("Cannot close index.html.");
        return;
    }
    
    const index = openTabs.indexOf(filepath);
    if (index > -1) {
        openTabs.splice(index, 1);
    }

    if (activeFilePath === filepath) {
        const newActiveIndex = Math.max(0, index - 1);
        const newActiveFile = openTabs.length > 0 ? openTabs[newActiveIndex] : null;
        if (newActiveFile) {
            switchTab(newActiveFile);
        } else {
            activeFilePath = null;
            editor.setValue('');
            renderAll();
        }
    } else {
        renderAll();
    }
}

function resolveInjections(code, processingStack = new Set()) {
    const injectionRegex = /\/\/\s*<<\s*([\w\d\._\/-]+)/g;
    return code.replace(injectionRegex, (match, path) => {
        const trimmedPath = path.trim();
        if (processingStack.has(trimmedPath)) {
            const errorMsg = `Circular dependency detected: ${[...processingStack, trimmedPath].join(' -> ')}`;
            logToConsole('error', errorMsg);
            return `console.error(${JSON.stringify(errorMsg)});`;
        }
        if (!files[trimmedPath]) {
            const errorMsg = `Injection error: File "${trimmedPath}" not found.`;
            logToConsole('error', errorMsg);
            return `console.error(${JSON.stringify(errorMsg)});`;
        }
        processingStack.add(trimmedPath);
        const injectedContent = files[trimmedPath].code;
        const resolvedInjectedContent = resolveInjections(injectedContent, processingStack);
        processingStack.delete(trimmedPath);
        return resolvedInjectedContent;
    });
}

function updateScene() {
    blobUrls.forEach(url => URL.revokeObjectURL(url));
    blobUrls.length = 0;

    if (!isPreviewMode && activeFilePath && files[activeFilePath]) {
        files[activeFilePath].code = editor.getValue();
    }

    let htmlCode = files['index.html'] ? files['index.html'].code : '<p style="color:red;">Error: index.html not found.</p>';
    if (files['index.html']) {
        htmlCode = resolveInjections(htmlCode, new Set(['index.html']));
    }

    const doc = new DOMParser().parseFromString(htmlCode, 'text/html');

    doc.querySelectorAll('script[src]').forEach(tag => {
        const src = tag.getAttribute('src');
        if (src && files[src]) {
            const processedCode = resolveInjections(files[src].code, new Set([src]));
            const blob = new Blob([processedCode], { type: 'application/javascript' });
            const url = URL.createObjectURL(blob);
            blobUrls.push(url);
            tag.src = url;
        }
    });

    doc.querySelectorAll('link[rel="stylesheet"][href]').forEach(tag => {
        const href = tag.getAttribute('href');
        if (files[href]) {
            const blob = new Blob([files[href].code], { type: 'text/css' });
            const url = URL.createObjectURL(blob);
            blobUrls.push(url);
            tag.href = url;
        }
    });

    const finalHtml = doc.documentElement.outerHTML;
    if (isPreviewMode) {
        scene.srcdoc = finalHtml;
    } else {
        const wrappedCode= `<script>
            window.onerror = (m,s,l,c,e) => { window.parent.postMessage({type: 'error', content: 'Error: ' + m}, '*'); return true; };
            const oL=console.log; console.log = (...a) => { window.parent.postMessage({type:'log', content:a.join(' ')},'*'); oL.apply(this,a);};
            const oE=console.error; console.error = (...a) => { window.parent.postMessage({type:'error', content:a.join(' ')},'*'); oE.apply(this,a);};
            window.addEventListener('beforeunload', e => e.stopImmediatePropagation());
        <\/script>` + finalHtml;
        scene.srcdoc = wrappedCode;
    }
}

if (!isPreviewMode) {
    editor.on("change", () => {
        if (liveUpdateToggle.checked) updateScene();
    });
    liveUpdateToggle.addEventListener('change', function() { if (this.checked) { editor.on("change", updateScene); updateScene(); } else { editor.off("change", updateScene); } });

    let showingEditor = false, showingConsole = false;
    function toggleEditor() {
        if (showingEditor) {
            editorElement.style.display = 'none';
            document.getElementById('file-tabs').style.display = 'none';
            document.querySelector('.live-update-switch').style.display = 'none';
            if (filePanel.classList.contains('open')) toggleFilePanel();
            scene.focus();
            scene.style.zIndex = '5';
            editorElement.style.pointerEvents = 'none';
            scene.style.pointerEvents = 'auto';
        } else {
            editorElement.style.display = 'block';
            document.getElementById('file-tabs').style.display = 'flex';
            document.querySelector('.live-update-switch').style.display = 'block';
            updateProjectTitle();
            editor.focus();
            scene.style.zIndex = '0';
            editorElement.style.pointerEvents = 'auto';
            scene.style.pointerEvents = 'none';
        }
        showingEditor = !showingEditor;
    }
    function toggleConsole() { consoleElem.style.display = showingConsole ? 'none' : 'block'; showingConsole = !showingConsole; }
    let altPressed = false, shiftAltPressed = false;
    document.addEventListener('keydown', e => { 
        if (isPreviewMode) return;
        if (e.key === 'Escape') { toggleMenu(); } 
        else if (e.altKey && !e.shiftKey && !altPressed) { e.preventDefault(); altPressed = true; toggleEditor(); } 
        else if (e.altKey && e.shiftKey && !shiftAltPressed) { e.preventDefault(); shiftAltPressed = true; toggleConsole(); } 
    });
    document.addEventListener('keyup', e => { 
        if (isPreviewMode) return;
        if (!e.altKey) { altPressed = false; shiftAltPressed = false; } 
    });
    scene.addEventListener('load', () => {
        if (scene.contentWindow) {
            scene.contentWindow.addEventListener('keydown', e => { 
                if (isPreviewMode) { e.preventDefault(); return; }
                if (e.key === 'Escape') { e.preventDefault(); toggleMenu(); } 
                else if (e.altKey && !e.shiftKey) { e.preventDefault(); toggleEditor(); } 
                else if (e.altKey && e.shiftKey) { e.preventDefault(); toggleConsole(); } 
            });
        }
    });
    function logToConsole(type, content) { 
      if (isPreviewMode) {
          console[type === 'error' ? 'error' : 'log'](`[Preview] ${content}`);
          return;
      }
      const logElem = document.createElement('div'); logElem.className = type; logElem.textContent = content; consoleElem.appendChild(logElem); consoleElem.scrollTop = consoleElem.scrollHeight; 
    }
    window.addEventListener('message', e => { if (e.source === scene.contentWindow) { logToConsole(e.data.type, e.data.content); } });
    editorElement.style.display = 'block'; consoleElem.style.display = 'none'; scene.style.zIndex = '0'; editor.focus(); editorElement.style.pointerEvents = 'auto'; scene.style.pointerEvents = 'none'; showingEditor = true;
    let fontSize = 14; editorElement.addEventListener('wheel', e => { if (e.ctrlKey) { e.preventDefault(); fontSize += e.deltaY > 0 ? -1 : 1; fontSize = Math.max(8, Math.min(24, fontSize)); editorElement.style.fontSize = fontSize + 'px'; editor.refresh(); } });
    let opacity = 0.5; editorElement.addEventListener('wheel', e => { if (e.shiftKey) { e.preventDefault(); opacity += e.deltaY > 0 ? -0.05 : 0.05; opacity = Math.max(0.1, Math.min(1, opacity)); editorElement.style.backgroundColor = `rgba(30, 30, 30, ${opacity})`; } });
    window.addEventListener('beforeunload', e => e.stopImmediatePropagation());
    function toggleMenu() { if (menu.style.display === 'none' || menu.style.display === '') { menu.style.display = 'flex'; loadSavedCodes(); } else { menu.style.display = 'none'; colorPicker.style.display = 'none'; } }
}

let db;
const DB_NAME = 'CodeEditorDB_Projects', DB_VERSION = 1, STORE_NAME = 'projects';
function openDB() { return new Promise((resolve, reject) => { const request = indexedDB.open(DB_NAME, DB_VERSION); request.onupgradeneeded = e => { db = e.target.result; if (!db.objectStoreNames.contains(STORE_NAME)) { db.createObjectStore(STORE_NAME, { keyPath: 'id', autoIncrement: true }); } }; request.onsuccess = e => { db = e.target.result; resolve(db); }; request.onerror = e => reject('Error opening database'); }); }
function saveCode(p) { return new Promise((res, rej) => { const r = db.transaction([STORE_NAME], 'readwrite').objectStore(STORE_NAME).add(p); r.onsuccess = e => res(e.target.result); r.onerror = e => rej('Error saving project'); }); }
function updateCode(p) { return new Promise((res, rej) => { const r = db.transaction([STORE_NAME], 'readwrite').objectStore(STORE_NAME).put(p); r.onsuccess = e => res(e.target.result); r.onerror = e => rej('Error updating project'); }); }
function deleteCode(id) { return new Promise((res, rej) => { const r = db.transaction([STORE_NAME], 'readwrite').objectStore(STORE_NAME).delete(id); r.onsuccess = () => res(); r.onerror = () => rej('Error deleting project'); }); }
function getCodes() { return new Promise((res, rej) => { const r = db.transaction([STORE_NAME], 'readonly').objectStore(STORE_NAME).getAll(); r.onsuccess = e => res(e.target.result); r.onerror = e => rej('Error getting projects'); }); }

async function saveCurrentCode(overwrite = false) {
    if (activeFilePath && files[activeFilePath]) files[activeFilePath].code = editor.getValue();
    const filesToSave = {};
    for (const filepath in files) filesToSave[filepath] = files[filepath].code;
    const now = new Date();

    if (overwrite && currentProjectId !== null) {
        const tx = db.transaction([STORE_NAME], 'readwrite');
        const store = tx.objectStore(STORE_NAME);
        const getReq = store.get(currentProjectId);
        getReq.onsuccess = e => {
            const project = e.target.result;
            if (project) {
                project.files = filesToSave;
                project.openTabs = openTabs;
                project.date = now;
                updateCode(project).then(loadSavedCodes);
                localStorage.setItem('lastOpenedProjectId', currentProjectId);
            }
        };
    } else {
        const newProject = { date: now, createdDate: now, files: filesToSave, openTabs: openTabs, name: '' };
        const id = await saveCode(newProject);
        currentProjectId = id;
        localStorage.setItem('lastOpenedProjectId', currentProjectId);
        loadSavedCodes();
    }
    updateProjectTitle();
}

async function loadProject(projectId) {
    const request = db.transaction([STORE_NAME], 'readonly').objectStore(STORE_NAME).get(projectId);
    request.onsuccess = async e => {
        const project = e.target.result;
        if (project && project.files) {
            currentProjectId = project.id;
            localStorage.setItem('lastOpenedProjectId', project.id);
            initializeEditorWithFiles(project.files, project.openTabs || []);
            await loadSavedCodes();
            updateProjectTitle();
        }
    };
}
async function loadSavedCodes() {
    const savedProjects = await getCodes();
    savedProjects.sort((a, b) => {
        const dateA = currentSortMode === 'created' ? (a.createdDate || a.date) : a.date;
        const dateB = currentSortMode === 'created' ? (b.createdDate || b.date) : b.date;
        return new Date(dateB) - new Date(dateA);
    });
    menu.innerHTML = `<div id="menu-controls"><div id="menu-main-actions"><button id="saveBtn">Save New Project</button><button id="exportToggleBtn">Export Projects</button><button id="exportAllBtn">Export All</button><button id="shareUrlBtn">Share as URL</button><button id="sharePreviewBtn">Share as Preview</button><button id="sortBtn"></button><button id="colorThemeBtn">Color Theme</button></div><div id="fileInfo"></div></div><div id="project-list"></div>`;
    const projectList = menu.querySelector('#project-list');
    savedProjects.forEach(project => {
        const button = document.createElement('button');
        const textContainer = document.createElement('span');
        if (project.name) textContainer.innerHTML = `<span class="name">${project.name}</span>`;
        textContainer.innerHTML += formatDate(new Date(project.date));
        const arrow = document.createElement('span');
        arrow.innerHTML = '↓';
        arrow.className = 'export-arrow';
        arrow.title = 'Export project as .zip';
        arrow.addEventListener('click', e => { e.stopPropagation(); exportProjectAsZip(project.id); e.currentTarget.classList.add('exported'); setTimeout(() => e.currentTarget.classList.remove('exported'), 300000); });
        button.appendChild(textContainer);
        button.appendChild(arrow);
        button.onclick = () => loadProject(project.id);
        button.oncontextmenu = e => {
            e.preventDefault();
            const name = prompt('Enter a name for this project:', project.name);
            if (name !== null) { project.name = name; updateCode(project).then(() => { loadSavedCodes(); updateProjectTitle(); }); }
        };
        button.onmousedown = e => {
            if (e.button === 1) {
                e.preventDefault();
                if (localStorage.getItem('lastOpenedProjectId') == project.id) localStorage.removeItem('lastOpenedProjectId');
                deleteCode(project.id).then(() => {
                    if (currentProjectId === project.id) { currentProjectId = null; initializeEditorWithFiles({ 'index.html': '' }, ['index.html']); }
                    loadSavedCodes(); updateProjectTitle(); updateFileInfo();
                });
            }
        };
        if (project.id === currentProjectId) button.classList.add('selected');
        projectList.appendChild(button);
    });
    document.getElementById('saveBtn').onclick = () => saveCurrentCode(false);
    document.getElementById('exportToggleBtn').onclick = () => projectList.classList.toggle('show-export-arrows');
    document.getElementById('exportAllBtn').onclick = exportAllProjectsAsZip;
    document.getElementById('shareUrlBtn').onclick = () => generateShareableUrl('#p=');
    document.getElementById('sharePreviewBtn').onclick = () => generateShareableUrl('#t=');
    const sortBtn = document.getElementById('sortBtn');
    sortBtn.textContent = `Sort by: ${currentSortMode==='created'?'Created':'Changed'}`;
    sortBtn.onclick = () => { currentSortMode = (currentSortMode === 'created') ? 'changed' : 'created'; localStorage.setItem('projectSortMode', currentSortMode); loadSavedCodes(); };
    document.getElementById('colorThemeBtn').onclick = () => { colorPicker.style.display = (colorPicker.style.display === 'none' || colorPicker.style.display === '') ? 'flex' : 'none'; };
    updateFileInfo();
    const savedScroll = localStorage.getItem('projectListScrollPosition');
    if (savedScroll) setTimeout(() => { projectList.scrollTop = parseInt(savedScroll, 10); }, 0);
    projectList.addEventListener('scroll', () => localStorage.setItem('projectListScrollPosition', projectList.scrollTop));
}

async function exportProjectAsZip(projectId) {
    try {
        const tx = db.transaction([STORE_NAME], 'readonly');
        const store = tx.objectStore(STORE_NAME);
        const request = store.get(projectId);
        
        request.onsuccess = e => {
            const project = e.target.result;
            if (project && project.files) {
                const zip = new JSZip();
                for (const filename in project.files) {
                    if (filename.split('/').pop() === '.p') continue;
                    zip.file(filename, project.files[filename]);
                }
                
                zip.generateAsync({ type: "blob" })
                    .then(function(content) {
                        const a = document.createElement("a");
                        const url = URL.createObjectURL(content);
                        a.href = url;
                        const projectName = (project.name || `project-${project.id}`).replace(/[\\/:*?"<>|]/g, '_');
                        a.download = `${projectName}.zip`;
                        document.body.appendChild(a);
                        a.click();
                        document.body.removeChild(a);
                        URL.revokeObjectURL(url);
                    });
            } else {
                alert('Project data not found.');
            }
        };

        request.onerror = e => {
            console.error("Failed to get project for export:", e);
            alert("Error: Failed to get project data for export.");
        };
    } catch (error) {
        console.error("Export function error:", error);
        alert("An error occurred during export.");
    }
}
async function exportAllProjectsAsZip() {
    try {
        const allProjects = await getCodes();
        if (allProjects.length === 0) {
            alert("No saved projects to export.");
            return;
        }

        const zip = new JSZip();

        for (const project of allProjects) {
            if (project && project.files) {
                const folderName = (project.name || `project-${project.id}`).replace(/[\\/:*?"<>|]/g, '_');
                const projectFolder = zip.folder(folderName);
                
                for (const filename in project.files) {
                    if (filename.split('/').pop() === '.p') continue;
                    if(projectFolder) {
                       projectFolder.file(filename, project.files[filename]);
                    }
                }
            }
        }

        zip.generateAsync({ type: "blob" })
            .then(function(content) {
                const a = document.createElement("a");
                const url = URL.createObjectURL(content);
                a.href = url;
                a.download = `all_projects_export.zip`;
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
                URL.revokeObjectURL(url);
            });

    } catch (error) {
        console.error("Error exporting all projects:", error);
        alert("An error occurred while exporting all projects.");
    }
}
function formatDate(d) {const s=(new Date()-d)/1000;if(s<60)return`${Math.round(s)}s`;if(s<3600)return`${Math.round(s/60)}m`;if(s<86400)return`${Math.round(s/3600)}h`;return`${Math.round(s/86400)}d`;}
function updateProjectTitle() {
    if (isPreviewMode) return;
    if (currentProjectId === null) {
        projectTitle.textContent = '📁 URL Project';
        projectTitle.title = 'Unsaved URL Project';
        checkOverflow();
        return;
    }
    getCodes().then(projects => {
        const currentProject = projects.find(p => p.id === currentProjectId);
        if (currentProject && currentProject.name) {
            projectTitle.textContent = `📁 ${currentProject.name}`;
            projectTitle.title = `Project: ${currentProject.name}`;
        } else {
            projectTitle.textContent = '📁 Project';
            projectTitle.title = 'Unnamed Project';
        }
        checkOverflow();
    });
}
function updateFileInfo() { if (isPreviewMode) return; getCodes().then(projects => { const totalSize = projects.reduce((acc, p) => acc + JSON.stringify(p.files).length, 0); const fileInfoEl = document.getElementById('fileInfo'); if(fileInfoEl) fileInfoEl.textContent = `${(totalSize/1024).toFixed(2)} KB, Projects: ${projects.length}`; }); }

function toggleFilePanel() {
    filePanel.classList.toggle('open');
    editorElement.classList.toggle('file-panel-open');
    document.getElementById('file-tabs').classList.toggle('file-panel-open');
    setTimeout(() => { editor.refresh(); checkOverflow(); }, 300);
}

if (!isPreviewMode) {
    projectTitle.addEventListener('click', toggleFilePanel);
    document.getElementById('add-file-btn').onclick = () => createNewItem(false, '');
}


function renderFilePanel() {
    if (isPreviewMode) return;
    filePanel.innerHTML = '';
    const paths = Object.keys(files);
    const tree = {};

    paths.forEach(path => {
        let currentLevel = tree;
        path.split('/').forEach((part, index, arr) => {
            if (index === arr.length - 1) {
                currentLevel[part] = { _is_file_: true, path: path };
            } else {
                if (!currentLevel[part]) currentLevel[part] = {};
                currentLevel = currentLevel[part];
            }
        });
    });

    function renderTree(node, container, depth) {
        Object.keys(node).sort().forEach(key => {
            if (key === '_is_file_' || key === '.p') return;
            const item = node[key];
            const div = document.createElement('div');
            div.style.paddingLeft = `${10 + depth * 15}px`;
            
            if (item._is_file_) {
                div.className = 'file-entry file';
                div.textContent = key;
                div.dataset.path = item.path;
                if (item.path === activeFilePath) div.classList.add('active');
                div.onclick = () => openFile(item.path);
            } else {
                div.className = 'file-entry folder';
                div.textContent = key;
                const currentPath = Object.values(item).find(v => v.path)?.path.substring(0, Object.values(item).find(v => v.path).path.indexOf(key) + key.length) || key;
                div.dataset.path = currentPath;
                renderTree(item, div, depth + 1);
            }
            container.appendChild(div);
        });
    }

    renderTree(tree, filePanel, 0);
    
    filePanel.addEventListener('contextmenu', e => {
        e.preventDefault();
        const target = e.target.closest('.file-entry');
        const path = target ? target.dataset.path : '';
        const isFolder = target ? target.classList.contains('folder') : true;
        showContextMenu(e.clientX, e.clientY, path, isFolder);
    });
}
function renderAll() {
    if (isPreviewMode) return;
    renderTabs();
    renderFilePanel();
}
if (!isPreviewMode) {
    filePanel.addEventListener('mousedown', e => {
        if (e.button !== 1) return;

        const target = e.target.closest('.file-entry');
        if (!target) return;

        e.preventDefault();

        const pathToDelete = target.dataset.path;
        const isFolder = target.classList.contains('folder');

        if (pathToDelete === 'index.html') {
            showNotification("Cannot delete index.html.");
            return;
        }

        if (isFolder) {
            const keysToDelete = Object.keys(files).filter(path => path.startsWith(pathToDelete + '/'));
            keysToDelete.forEach(path => {
                closeTab(path);
                delete files[path];
            });
        } else {
            closeTab(pathToDelete);
            delete files[pathToDelete];
        }

        renderAll();
    });
}


function showContextMenu(x, y, path, isFolder) {
    contextMenu.style.left = `${x}px`;
    contextMenu.style.top = `${y}px`;
    contextMenu.style.display = 'block';

    let menuItems = `<div id="ctx-new-file">New File</div><div id="ctx-new-folder">New Folder</div>`;
    if (path && path !== 'index.html') {
        menuItems += `<div id="ctx-rename">Rename</div><div id="ctx-delete">Delete</div>`;
    }
    contextMenu.innerHTML = menuItems;

    document.getElementById('ctx-new-file').onclick = () => createNewItem(false, isFolder ? path : path.substring(0, path.lastIndexOf('/')));
    document.getElementById('ctx-new-folder').onclick = () => createNewItem(true, isFolder ? path : path.substring(0, path.lastIndexOf('/')));
    if (path && path !== 'index.html') {
        document.getElementById('ctx-rename').onclick = () => renameItem(path, isFolder);
        document.getElementById('ctx-delete').onclick = () => deleteItem(path, isFolder);
    }
}

if (!isPreviewMode) {
    document.addEventListener('click', () => contextMenu.style.display = 'none');
}


function createNewItem(isFolder, basePath) {
    const type = isFolder ? 'folder' : 'file';
    let name = prompt(`Enter new ${type} name:`);
    if (!name) return;
    const newPath = basePath ? `${basePath}/${name}`.replace(/^\//, '') : name;

    if (isFolder) {
        const placeholderPath = `${newPath}/.p`;
        if (files[placeholderPath]) { alert('Folder already exists.'); return; }
        files[placeholderPath] = { code: '', doc: CodeMirror.Doc('', 'text/plain')};
    } else {
        if (files[newPath]) { alert('File already exists.'); return; }
        files[newPath] = { code: '', doc: CodeMirror.Doc('', getModeForFilename(newPath))};
        openFile(newPath);
    }
    renderAll();
}

function renameItem(oldPath, isFolder) {
    const oldName = oldPath.split('/').pop();
    const newName = prompt('Enter new name:', oldName);
    if (!newName || newName === oldName) return;

    const basePath = oldPath.substring(0, oldPath.lastIndexOf('/'));
    const newPath = basePath ? `${basePath}/${newName}` : newName;

    if (isFolder) {
        Object.keys(files).forEach(path => {
            if (path.startsWith(oldPath + '/')) {
                const updatedPath = path.replace(oldPath, newPath);
                files[updatedPath] = files[path];
                delete files[path];
                const openTabIndex = openTabs.indexOf(path);
                if (openTabIndex > -1) openTabs[openTabIndex] = updatedPath;
            }
        });
        if (activeFilePath && activeFilePath.startsWith(oldPath + '/')) {
            activeFilePath = activeFilePath.replace(oldPath, newPath);
        }
    } else {
        if (files[newPath]) { alert('A file with that name already exists.'); return; }
        files[newPath] = files[oldPath];
        delete files[oldPath];
        const openTabIndex = openTabs.indexOf(oldPath);
        if (openTabIndex > -1) openTabs[openTabIndex] = newPath;
        if (activeFilePath === oldPath) activeFilePath = newPath;
    }
    renderAll();
}

function deleteItem(pathToDelete, isFolder) {
    if (!confirm(`Are you sure you want to delete "${pathToDelete}"? This cannot be undone.`)) return;
    
    if (isFolder) {
        Object.keys(files).forEach(path => {
            if (path.startsWith(pathToDelete + '/')) {
                closeTab(path);
                delete files[path];
            }
        });
    } else {
        closeTab(pathToDelete);
        delete files[pathToDelete];
    }
    renderAll();
}
if (!isPreviewMode) {
    const colorTypes = { Comment: 'comment', Keyword: 'keyword', String: 'string', Number: 'number', Special: 'atom', Variable: 'variable', Property: 'property', Definition: 'def', Function: 'variable-2', Operator: 'operator', HTMLBracket: 'bracket', HighlightedBracket: 'matchingbracket', Class: 'variable-3', Regex: 'string-2', HTMLTag: 'tag', HTMLAttribute: 'attribute', OtherText: 'text' };
    const defaultColors = {"Comment":"#04ff00","Keyword":"#0064ff","String":"#ffff00","Number":"#ffffff","Special":"#ff00ae","Variable":"#c880ff","Property":"#757ad7","Definition":"#ff8000","Function":"#00b3ff","Operator":"#ffffff","HTMLBracket":"#fe2aec","HighlightedBracket":"#ff0000","Class":"#00ff88","Regex":"#ff00ff","HTMLTag":"#00b3ff","HTMLAttribute":"#ff7aff","OtherText":"#878787"};
    function changeColor(type) { const color = document.getElementById(type).value; const style = document.createElement('style'); document.head.appendChild(style); const sheet = style.sheet; if (type === 'HighlightedBracket') sheet.insertRule(`.cm-s-monokai .CodeMirror-${colorTypes[type]} { background-color: ${color} !important; color: #000000 !important; }`, 0); else if (type === 'OtherText') sheet.insertRule(`.cm-s-monokai { color: ${color} !important; }`, 0); else sheet.insertRule(`.cm-s-monokai span.cm-${colorTypes[type]} { color: ${color} !important; }`, 0); localStorage.setItem(`color-${type}`, color); }
    function loadColors() { for (const type in colorTypes) { const color = localStorage.getItem(`color-${type}`) || defaultColors[type]; if (color) { document.getElementById(type).value = color; changeColor(type); } } }
    for (const type in colorTypes) document.getElementById(type).addEventListener('change', () => changeColor(type));
    function exportSettings() { const settings = {}; for (const type in colorTypes) settings[type] = localStorage.getItem(`color-${type}`); const a = document.createElement('a'); a.href = URL.createObjectURL(new Blob([JSON.stringify(settings)], {type: "application/json"})); a.download = "code_editor_settings.json"; a.click(); URL.revokeObjectURL(a.href); }
    function importSettings() { const input = document.createElement('input'); input.type = 'file'; input.accept = '.json'; input.onchange = e => { const file = e.target.files[0]; const reader = new FileReader(); reader.onload = e => { const settings = JSON.parse(e.target.result); for (const type in settings) if (colorTypes.hasOwnProperty(type)) { localStorage.setItem(`color-${type}`, settings[type]); document.getElementById(type).value = settings[type]; changeColor(type); } }; reader.readAsText(file); }; input.click(); }
    exportBtn.addEventListener('click', exportSettings); importBtn.addEventListener('click', importSettings);
}


function loadFallbackProject() {
    getCodes().then(projects => {
        if (projects.length > 0) {
            savedProjects.sort((a, b) => { const dateA = currentSortMode === 'created' ? (a.createdDate || a.date) : a.date; const dateB = currentSortMode === 'created' ? (b.createdDate || b.date) : b.date; return new Date(dateB) - new Date(dateA); });
            loadProject(projects[0].id);
        } else {
            initializeEditorWithFiles({ 'index.html': '' }, ['index.html']);
        }
        loadColors();
    });
}


if (isPreviewMode) {
    if (location.hash.startsWith('#t=')) {
        try {
            const encodedData = location.hash.substring(3);
            const compressedBytes = decodeBaseCustom(encodedData);
            const decompressed = pako.ungzip(compressedBytes);
            const binaryData = new Uint8Array(decompressed);
            const { filesToLoad } = deserializeProjectOptimized(binaryData);

            if (Object.keys(filesToLoad).length > 0) {
                for (const filepath in filesToLoad) {
                   files[filepath] = { code: filesToLoad[filepath] };
                }
                updateScene();
            } else {
                 scene.srcdoc = `<h1>Error</h1><p>Could not load project from URL.</p>`;
            }
        } catch(e) {
            console.error("URL preview load error:", e);
            scene.srcdoc = `<h1>Error</h1><p>Invalid or corrupted preview link.</p>`;
        }
    } else {
        openDB().then(() => {
            const lastOpenedIdStr = localStorage.getItem('lastOpenedProjectId');
            if (!lastOpenedIdStr) {
                scene.srcdoc = "<h1>Error</h1><p>No project ID found in local storage. Please run a project from the editor first.</p>";
                return;
            }
            const lastOpenedId = parseInt(lastOpenedIdStr, 10);
            const request = db.transaction([STORE_NAME], 'readonly').objectStore(STORE_NAME).get(lastOpenedId);
            request.onsuccess = e => {
                const project = e.target.result;
                if (project && project.files) {
                    for (const filepath in project.files) {
                       files[filepath] = { code: project.files[filepath] };
                    }
                    updateScene();
                } else {
                    scene.srcdoc = `<h1>Error</h1><p>Project with ID ${lastOpenedId} not found.</p>`;
                }
            };
            request.onerror = e => {
                scene.srcdoc = `<h1>Error</h1><p>Could not access the project database.</p>`;
            }
        });
    }

} else {
    copyBtn.addEventListener('click', () => {
        if (activeFilePath && files[activeFilePath]) {
            files[activeFilePath].code = editor.getValue();
        }

        const output = [];
        const fileKeys = Object.keys(files).sort();
        
        const indexHtmlPosition = fileKeys.indexOf('index.html');
        if (indexHtmlPosition > -1) {
            fileKeys.splice(indexHtmlPosition, 1);
            fileKeys.unshift('index.html');
        }

        for (const path of fileKeys) {
            if (path.split('/').pop() === '.p') continue;

            if (files[path]) {
                output.push(`${path}\n\`\`\`\n${files[path].code}\n\`\`\``);
            }
        }

        const textToCopy = output.join('\n\n');

        navigator.clipboard.writeText(textToCopy).then(() => {
            showNotification('Code for all files copied');
        }).catch(err => {
            console.error('Failed to copy text: ', err);
            showNotification('Error: Could not copy code');
        });
    });

    if (pasteProjectBtn) {
        pasteProjectBtn.addEventListener('click', async () => {
            try {
                const text = await navigator.clipboard.readText();
                if (!text) {
                    showNotification('Clipboard is empty.');
                    return;
                }

                const newFileSet = {};
                const regex = /^(.+?)\s*\r?\n\`\`\`(?:.*)\r?\n([\s\S]+?)\r?\n\`\`\`/gm;
                let match;
                let foundFiles = false;

                while ((match = regex.exec(text)) !== null) {
                    foundFiles = true;
                    const filename = match[1].trim();
                    const code = match[2];
                    if (filename) {
                        newFileSet[filename] = code;
                    }
                }
                
                if (!foundFiles) {
                    showNotification('Could not parse files from clipboard. Use format:\nfilename\n```\ncode\n```\n...for each file.');
                    return;
                }
                
                currentProjectId = null;
                
                const newOpenTabs = Object.keys(newFileSet);
                const indexHtmlIdx = newOpenTabs.indexOf('index.html');
                if (indexHtmlIdx > -1) {
                    newOpenTabs.splice(indexHtmlIdx, 1);
                    newOpenTabs.unshift('index.html');
                }

                initializeEditorWithFiles(newFileSet, newOpenTabs);
                updateProjectTitle();
                
                showNotification('Project loaded from clipboard.');

            } catch (err) {
                console.error('Failed to read clipboard or parse project:', err);
                if (err.name === 'NotAllowedError') {
                   showNotification('Clipboard access denied by browser.');
                } else {
                   showNotification('Error: Could not load from clipboard.');
                }
            }
        });
    }
    
    runBtn.addEventListener('click', async () => {
        await saveCurrentCode(true);
        window.open(`${location.origin}${location.pathname}#t`, '_blank');
    });

    openDB().then(async () => {
        if (await loadFromUrlHash()) {
            loadColors();
            return;
        }
        const lastOpenedIdStr = localStorage.getItem('lastOpenedProjectId');
        if (lastOpenedIdStr) {
            const lastOpenedId = parseInt(lastOpenedIdStr, 10);
            const request = db.transaction([STORE_NAME], 'readonly').objectStore(STORE_NAME).get(lastOpenedId);
            request.onsuccess = e => {
                if (e.target.result) { loadProject(lastOpenedId); loadColors(); }
                else { localStorage.removeItem('lastOpenedProjectId'); loadFallbackProject(); }
            };
            request.onerror = e => { console.error("Error checking last project:", e); localStorage.removeItem('lastOpenedProjectId'); loadFallbackProject(); };
        } else {
            loadFallbackProject();
        }
    });
}
</script>
</body>
</html>
